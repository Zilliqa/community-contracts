scilla_version 0

import IntUtils BoolUtils ListUtils PairUtils

library SingleSidedAssetStaking
let bool_true = True
let uint128_zero = Uint128 0
let uint128_one = Uint128 1
let empty_bystr = 0x0000000000000000000000000000000000000000
let tax_bps_min = Uint128 0 (* 0.00% *)
let tax_bps_max = Uint128 10000 (* 100.00% *)
let min_stake_amount = Uint128 10 (* the minimum amount required to be staked / withdrew (cannot be left with less than Uint128 10 token balance) *)

type UserSSAS  =  | UserSSAS of BNum    (* block entered staking *)
                                Uint128 (* deposited tokens *)

type TokenMove = | UserToContract | ContractToUser
let user_to_contract        = UserToContract
let contract_to_user        = ContractToUser
 
let one_msg = 
    fun (msg : Message) => 
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg

let two_msgs =
    fun (msg1 : Message) =>
    fun (msg2 : Message) =>
        let msgs_tmp = one_msg msg2 in
        Cons {Message} msg1 msgs_tmp

 (* @dev: When passing a Uint128 value, returns a Uint256 of that value *)      
let uint128_to_uint256 : Uint128 -> Uint256 =
  fun (x : Uint128) =>
    let ox256 = builtin to_uint256 x in
      match ox256 with
      | None => (* this never happens, hence we throw a division by zero exception just in case *)
        let zero = Uint256 0 in
        builtin div zero zero
      | Some x256 => x256
      end
      
 (* @dev: When passing a Int256 value, returns a Uint128 of that value *)      
let int256_to_uint128 : Int256 -> Uint128 =
  fun (x : Int256) =>
    let ox128 = builtin to_uint128 x in
      match ox128 with
      | None => (* this never happens, hence we throw a division by zero exception just in case *)
        let zero = Uint128 0 in
        builtin div zero zero
      | Some x128 => x128
      end
         
(* @dev: Compute "(x * y) / z" with protection against integer overflows *)
let muldiv : Uint128 -> Uint128 -> Uint128 -> Uint128 =
    fun (x : Uint128) =>
    fun (y : Uint128) =>
    fun (z : Uint128) =>
      let x256 = uint128_to_uint256 x in
      let y256 = uint128_to_uint256 y in
      let z256 = uint128_to_uint256 z in
      let x_mul_y256 = builtin mul x256 y256 in
      let res256 = builtin div x_mul_y256 z256 in
      let ores128 = builtin to_uint128 res256 in
      match ores128 with
      | None => (* this must never happen, hence we throw an integer overflow exception *)
        let max_uint128 = Uint128 340282366920938463463374607431768211455 in
        let fourtytwo128 = Uint128 42 in
        builtin mul max_uint128 fourtytwo128
      | Some res128 =>
        res128
      end

(* @dev: Foreaching each person in pool, if they are eligible, accumulate the amount for all eligible addresses *)
let list_sum_if_eligible =
  fun (l : List (Pair ByStr20 UserSSAS)) =>
  fun (epoch_length : Uint128) => (* the current epoch length *)
  fun (now : BNum) => (* now in btime*)
    let foldl = @list_foldl (Pair ByStr20 UserSSAS) Uint128 in
    let init = Uint128 0 in
    let iter =
      fun (sum : Uint128) =>
      fun (list_element : Pair ByStr20 UserSSAS) =>
        match list_element with 
        | Pair _ (UserSSAS enter_stake_block currently_deposited_tokens) =>
          let user_address = let fst_string_bystr20 = @fst ByStr20 UserSSAS in fst_string_bystr20 list_element in
          let min_valid_claim = builtin badd enter_stake_block epoch_length in
          let is_past = builtin blt now min_valid_claim in 
            match is_past with
              | False => (* claiming for an eligble staking duration period *)
                 builtin add sum currently_deposited_tokens
              | True =>
                sum
            end
        end 
    in
    foldl iter init l

(* @dev: Foreaching each person in pool, if they are eligible, then calculate their percentage of the epoch total rewards. Returns a reward Map ByStr20 Uint128 *)
(* @dev: When calculating multiple epochs, it is assumed everyone in the map is valid since list_sum_if_eligible will return true as long as epochs_to_reward>=1 *)
let get_updated_reward_map_if_eligible =
  fun (l : List (Pair ByStr20 UserSSAS)) => (* pool.toList *)
  fun (sum_at_epoch : Uint128) => (* the total of the pool calculated once *)
  fun (now : BNum) => (* now in btime*)
  fun (epoch_length : Uint128) => (* the current epoch length *)
  fun (reward_per_epoch : Uint128) => (* reward to distribute if valid on an epoch*)
  fun (reward_map : Map ByStr20 Uint128) => (* reward.toList *)
  fun (epochs_to_reward: Uint128) => (* amount of epochs to reward for: will be minimum 1, assumes no user has claimed for N+1 or longer epochs, so reward users for time (what if this is left for too long, and no one claims, then one person could claim everything if they staked over time) *)
    let foldl = @list_foldl 
      (Pair ByStr20 UserSSAS) (* what we are foreaching*)
      (Map ByStr20 Uint128) in (* accumulator what's returned each time *)
    let init = Uint128 0 in
    let iter =
      fun (acc : Map ByStr20 Uint128) => (* whats returned, an updated map of entries *)
      fun (list_element : Pair ByStr20 UserSSAS) => (* current head list element, iterated through *)
        match list_element with 
        | Pair _ (UserSSAS enter_stake_block currently_deposited_tokens) =>
          let user_address = let fst_string_bystr20 = @fst ByStr20 UserSSAS in fst_string_bystr20 list_element in
          let min_valid_claim = builtin badd enter_stake_block epoch_length in
          let is_past = builtin blt now min_valid_claim in 
            match is_past with
              | False => (* claiming for an eligble staking duration period *)
                    let user_share_of_rewards_at_this_epoch_as_uint256 = muldiv currently_deposited_tokens reward_per_epoch sum_at_epoch in
                    let maybe_user_share_of_rewards_at_this_epoch = builtin to_uint128 user_share_of_rewards_at_this_epoch_as_uint256 in
                    let maybe_previous_reward = builtin get acc user_address in
                          match maybe_previous_reward with
                            | Some previous_reward => (* previously have an entry*)
                                match maybe_user_share_of_rewards_at_this_epoch with
                                  | Some user_share_of_rewards_at_this_epoch =>
                                    let new_total_over_time = builtin mul user_share_of_rewards_at_this_epoch epochs_to_reward in
                                    let new_total_plus_existing = builtin add previous_reward new_total_over_time in
                                    builtin put acc user_address new_total_plus_existing 
                                  | None => (* shouldn't get here noop *)
                                    acc
                                end
                            | None => (* first epoch eligible, create map entry*)
                                match maybe_user_share_of_rewards_at_this_epoch with
                                  | Some user_share_of_rewards_at_this_epoch =>
                                     let new_total_over_time = builtin mul user_share_of_rewards_at_this_epoch epochs_to_reward in
                                     builtin put acc user_address new_total_over_time 
                                  | None => (* shouldn't get here noop *)
                                    acc
                                end
                          end
              | True => (* arent eligible noop *) (* if multiple epochs then everyone is eligible to (rewards*N) since an unstake/restake/withdraw would cause the contract to reward *)
                acc
              end
          end
    in
    foldl iter reward_map l 

type Error =
  | NotContractOwner  
  | NotStagingOwner
  | StagingOwnerNotConfigured 
  | SenderHasNoRewards
  | SenderHasNoFundsAtContract
  | SentRewardsNotAMutipleOfRewardPerEpoch
  | MathError
  | ContractIsPaused
  | OutOfBoundsTaxBpsValue
  | NotBelowMinimumStake
  | ContractShouldBeEmergencyPaused 

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | NotContractOwner                              => Int32 -1
      | NotStagingOwner                               => Int32 -2
      | StagingOwnerNotConfigured                     => Int32 -3
      | SenderHasNoRewards                            => Int32 -4
      | SenderHasNoFundsAtContract                    => Int32 -5
      | SentRewardsNotAMutipleOfRewardPerEpoch        => Int32 -6
      | MathError                                     => Int32 -7 
      | ContractIsPaused                              => Int32 -8
      | OutOfBoundsTaxBpsValue                        => Int32 -9
      | NotBelowMinimumStake                          => Int32 -10
      | ContractShouldBeEmergencyPaused               => Int32 -11
      end
    in
    { _exception : "Error"; code : result_code; res : result}
    
contract SingleSidedAssetStaking
(
  init_contract_owner: ByStr20,
  stake_token_contract: ByStr20 with contract end, 
  reward_token_contract: ByStr20 with contract end,
  reward_per_epoch: Uint128,  (* rewarded in total per epoch *)
  epoch_calculation_period_length: Uint128, (* ~2500bpd * 7d = 17500b as uint - time to rewards *)
  init_minimum_lock_time_no_tax: Uint128, (* 3d as uint - time to leave with no tax *)
  init_early_leave_tax: Uint128    (* 0.1% = 1bps / 10% = 1000bps / 100% = 10000bps *)
)
with
  let is_valid_min = uint128_ge init_early_leave_tax tax_bps_min in
  let is_valid_max = uint128_lt init_early_leave_tax tax_bps_max in 
  andb is_valid_min is_valid_max 
=>

field emergency_pause: Bool = False (* stops deposits/claimrewards/withdraws across the whole contract (everything) *)
field soft_pause: Bool = False      (* allows claiming of rewards and stake, but not depositing more stake or more rewards - flipped true when expired<now*)

field current_contract_owner: ByStr20  = init_contract_owner (* owner of owner functions *)
field staged_contract_owner: Option ByStr20 = None {ByStr20} (* owner can surrender ownership to an address. 2 step: stage, confirm to set a new current_owner*)

field total_taxed_amount: Uint128 = uint128_zero  (* totals the amount taxed, allows current_owner to withdraw *)
field total_amount_locked: Uint128 = uint128_zero (* total amount locked by users *)
field total_rewards_left: Uint128 = uint128_zero (* total amount of rewards deposited able to be claimed in the future, can be topped-up *)
field current_early_leave_tax: Uint128 = init_early_leave_tax (* mutable tax rate on leaving pool before an epoch duration *)
field current_minimum_lock_time_no_tax: Uint128 = init_minimum_lock_time_no_tax (* mutable minimum time to leave pool without being taxed*)

field next_epoch_block: BNum = builtin badd _creation_block epoch_calculation_period_length (* first epoch time be = time_at_deployment+epoch_length*)
field previously_rewarded_epoch_block: BNum = _creation_block
field epochs_rewards_expire: BNum = _creation_block
field amount_of_epochs_to_reward: Uint128 = uint128_zero 


field pool: Map ByStr20 UserSSAS = Emp ByStr20 UserSSAS (* user_address -> (enter_stake_block, deposited_tokens *) (* stores users deposits*)
field reward: Map ByStr20 Uint128 = Emp ByStr20 Uint128 (* user_address-> earnt_accum_reward *) (* calculates dynamically reward over time*)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsContractOwner()
  cco <- current_contract_owner;
  is_contract_owner = builtin eq cco _sender;
    match is_contract_owner with
      | True => 
      | False =>
        err = NotContractOwner;
        ThrowError err
    end
end

(* @dev: Throws an error if emergency_pause is true *)
procedure IsNotEmergencyPaused()
  is_paused <- emergency_pause;
  match is_paused with
    | True => 
      err = ContractIsPaused;
      ThrowError err
    | False =>
  end
end

(* @dev: Throws an error if soft_pause is true *)
procedure IsNotSoftPaused()
  is_paused <- soft_pause;
  match is_paused with
    | True => 
      err = ContractIsPaused;
      ThrowError err
    | False =>
  end
end

(* @dev: cannot leave user with less than 10 balance after an operation. amount cannot be zero  *)
procedure IsValidAmount(user_amount: Uint128)
  is_greater_than_min = uint128_ge user_amount min_stake_amount;
  match is_greater_than_min with
    | True =>
    | False => 
      err = NotBelowMinimumStake;
      ThrowError err
  end
end

(* @dev: cannot leave user with less than 10 balance after an operation, amount can be zero  *)
procedure IsValidAmountOrZero(user_amount: Uint128)
  is_greater_than_min = uint128_ge user_amount min_stake_amount;
  is_zero = builtin eq user_amount uint128_zero;
  is_valid = orb is_greater_than_min is_zero;
  match is_valid with
    | True =>
    | False => 
      err = NotBelowMinimumStake;
      ThrowError err
  end
end

(* @dev: Move an amount of fungible tokens from a particular contract either to the user or from the user *)
procedure ChangeContractOwnershipIfSenderIsStagingOwner()
  maybe_staged_contract_owner <- staged_contract_owner;
  match maybe_staged_contract_owner with
  | Some staged_owner =>
      caller_is_staged_owner = builtin eq _sender staged_owner;
      match caller_is_staged_owner with
      | True =>
          current_contract_owner := staged_owner;
          reset_staged_owner = None {ByStr20};
          staged_contract_owner := reset_staged_owner
      | False =>
        err = NotStagingOwner;
        ThrowError err
      end
  | None =>  
    err = StagingOwnerNotConfigured;
    ThrowError err
  end 
end

(* @dev: Move an amount of fungible tokens from a particular contract either to the user or from the user *)
(* @Requirements: *)
(* - `fungible_contract` should have an allowance with this contract address otherwise an `CodeInsufficientAllowance` error is thrown *)
(* - `amount` should have an equal to or less spender allowance otherwise an `CodeInsufficientFunds` error is thrown *)
procedure MoveFungibleTokenFromXToY(token_move: TokenMove, fungible_contract:ByStr20 with end, from: ByStr20, to: ByStr20, amount: Uint128)
  match token_move with
    | UserToContract =>
        transfer_to_contract = {
          _tag: "TransferFrom";
          _recipient: fungible_contract;
          _amount: uint128_zero;
          from: from;
          to: to;
          amount: amount
          };
        msgs = one_msg transfer_to_contract;
        send msgs
    | ContractToUser =>
        transfer_to_user = {
          _tag: "Transfer";
          _recipient: fungible_contract;
          _amount: uint128_zero;
          to: to;
          amount: amount
        };
        msgs = one_msg transfer_to_user;
        send msgs
    end
end

(* @dev: Triggered when now >= next_epoch_block. If eligible, dynamically calculates and sets users rewards for an epoch into 'reward'  *)
(* @Requirements: *)
(* To be eligible for rewards when this is ran. Users have to be deposted for (enter_stake_block + epoch_length) *)
(* If triggered when (now > next_epoch_block * 2) or greater, will mutitrigger accumulative rewards *)
(* If no-one is in the pool when triggered, skip till the next epoch (catch up till now) *)
procedure RewardIfEpoch()
  now <-& BLOCKNUMBER;
  calculation_block <- next_epoch_block;
  rewards_expiry_block <- epochs_rewards_expire;
  pool_map <- pool;
  (* check if we have valid entries, else we can skip epochs*)
  pool_to_list = builtin to_list pool_map;
  sum_at_epoch = list_sum_if_eligible pool_to_list epoch_calculation_period_length now; 
  is_zero = builtin eq sum_at_epoch uint128_zero; 
  match is_zero with
    | True => (* skip the epoch *)
      gap_between_epochs_as_uint256 = builtin bsub now calculation_block; (* either in the future or past, just increment epoch to closest to now*)
      gap_between_epochs = int256_to_uint128 gap_between_epochs_as_uint256;
      (* calculate how many epochs have been skipped*)
      epochs_skipped = builtin div gap_between_epochs epoch_calculation_period_length;
      (* calculate how many blocks have been skipped *)
      future_epoch_over_time = builtin mul epoch_calculation_period_length epochs_skipped; (* 99 * 2 = 198 *)
      (* calculate when rewards expire *)
      rewards_plus_skipped_epoch = builtin badd rewards_expiry_block future_epoch_over_time;
      (* calculate when next epoch is *)
      next_epoch_plus_skipped = builtin badd calculation_block future_epoch_over_time;
      (* set epoch state *)
      next_epoch_block := next_epoch_plus_skipped;
      epochs_rewards_expire := rewards_plus_skipped_epoch;
      e = {_eventname : "UserCountIsZeroSkippingEpochs"; now: now; old_expire: rewards_expiry_block; new_expire: rewards_plus_skipped_epoch; difference: future_epoch_over_time; 
                                                         next_epoch_block: next_epoch_plus_skipped; epochs_rewards_expire: rewards_plus_skipped_epoch };
      event e
    | False => (* calculate the reward *)
      (* how many epochs have we missed - RewardIfEpoch is triggered when users interact, so if left over multiple epochs, we can assume no state change happened between epochs *)
      gap_between_epochs_as_uint256 = builtin bsub now calculation_block; (* 100621 - 100400 = 221 assume now>calculation_block*)
      gap_between_epochs = int256_to_uint128 gap_between_epochs_as_uint256;
      (* calculate how many epochs have been skipped*)
      epochs_to_reward = builtin div gap_between_epochs epoch_calculation_period_length; (* 221 / 99 = 2 *) (* at minimum this will be 1, otherwise above match runs for false *)
      
      (* is rewards left to claim? *)
      rewards_epoch_left <- amount_of_epochs_to_reward;
      is_greater_equal_than = uint128_ge epochs_to_reward  rewards_epoch_left; (* epochs = 8 rewards = 10 // left = 2 / reward = 8*)
      match is_greater_equal_than with
        | True => (* if epochs_to_reward is larger than rewards_epoch_left, we are way into the future, only reward rewards_epoch_left and set softpause true *)
          (* calculate how many blocks have passed *)
          future_epoch_over_time = builtin mul epoch_calculation_period_length epochs_to_reward; (* 99 * 2 = 198 *)
          (* calculate how many rewards should be distributed for the missed epochs *)
          rewards_generated = builtin mul reward_per_epoch epochs_to_reward; (*DEBUG*)
          (* calculate when next epoch is (last+epochs=new_past)*)
          new_past_epoch = builtin badd calculation_block future_epoch_over_time; 
          (* calculate this_epoch from next_epoch (new_past+epochlength=new_future)*)
          new_future_epoch = builtin badd new_past_epoch epoch_calculation_period_length;
          (* pool has some amount>0, and it's time to reward 1 or more epochs *)
          reward_map <- reward;
          (* sum all old rewards with the newly eligible rewards *)
          new_reward_map = get_updated_reward_map_if_eligible pool_to_list sum_at_epoch now epoch_calculation_period_length reward_per_epoch reward_map rewards_epoch_left;
          (* set reward *)
          reward := new_reward_map;
          (* set epoch state *)
          previously_rewarded_epoch_block := new_past_epoch;
          next_epoch_block := new_future_epoch; 
          (* set rewards left *)
          new_epochs_remaining_to_reward = builtin sub rewards_epoch_left epochs_to_reward;
          amount_of_epochs_to_reward := new_epochs_remaining_to_reward;
          (* set softpause true*)
          soft_pause := bool_true;
          e = {_eventname : "MutiRewardForValidEpochsLeft"; rewarded_epochs: rewards_epoch_left };
          event e;
          e1 = {_eventname : "SnapshotRewardSuccess"; 
                              triggered_for_epoch: calculation_block; 
                              epochs_elapsed: epochs_to_reward;
                              blocks_elapsed: future_epoch_over_time;
                              new_past_epoch : new_future_epoch;
                              previously_rewarded_epoch_block: new_past_epoch;
                              rewards_generated:rewards_generated };
          event e1
        | False => (* rewarding mutiple, meaning some rewards will be leftover after rewarding *)
        
          e = {_eventname : "MutiRewardForEpochsElapsed"; rewarded_epochs: rewards_epoch_left };
          event e
      end
  end
end

(* @dev: Allows a user to deposit an amount of tokens into the contract *)
(* @dev: On increasing an already existing deposit, a new tax_threshold block is generated and you restart your tax-free duration starting from this_block *)
(* @dev: If softpaused error // if emergencypaused error *)
(* @Requirements: *)
(* - `fungible_contract` should have an allowance with this contract address otherwise an `CodeInsufficientAllowance` error is thrown *)
(* - `deposit_amount` should have an equal to or less spender allowance otherwise an `CodeInsufficientFunds` error is thrown *)
transition Deposit(deposit_amount: Uint128)
  IsNotEmergencyPaused;
  IsNotSoftPaused;
  now <-& BLOCKNUMBER;
  maybe_exists <- pool[_sender];
  amount_locked <- total_amount_locked;
  deposit_lock_duration = builtin badd now epoch_calculation_period_length;
  match maybe_exists with
    | Some some_user_ssas => (* user already exists, increase amount of tokens *)
      match some_user_ssas with
        | UserSSAS enter_stake_block currently_deposited_tokens =>
          
            new_deposited_tokens = builtin add currently_deposited_tokens deposit_amount;
            user_ssas = UserSSAS deposit_lock_duration    (* new lock duration            *)
                                 new_deposited_tokens;    (* addition to tokens staked    *)
            
            (* move tokens to contract *)
            MoveFungibleTokenFromXToY user_to_contract stake_token_contract _sender _this_address deposit_amount; (* deposit amount. not recalculated addition*)
            
            pool[_sender] := user_ssas;
            new_amount_locked = builtin add amount_locked deposit_amount;
            total_amount_locked := new_amount_locked;
            e = {_eventname : "IncreasingDepositSuccess"; user_ssas : user_ssas };
            event e
        end
    | None => (* user doesn't exist, initalise ssas *)
      IsValidAmount deposit_amount; (* need to deposit above minimum*)
      
      user_ssas = UserSSAS deposit_lock_duration (* new lock duration     *)
                           deposit_amount;       (* initial deposit amount *)
                           
      MoveFungibleTokenFromXToY user_to_contract stake_token_contract _sender _this_address deposit_amount;
            
      pool[_sender] := user_ssas;
      new_amount_locked = builtin add amount_locked deposit_amount;
      total_amount_locked := new_amount_locked;
      e = {_eventname : "InitalDepositSuccess"; user_ssas : user_ssas };
      event e
  end;
  RewardIfEpoch (* for a deposit this needs to go at the end, so that any eligible users, if depositing and is the epoch snapshot, become ineligible after the block time is updated *)
end

(* @dev: Allows a user to claim all accumulated rewards they are eligible for *)
(* @Requirements: *)
(* - `reward[_sender]` should have a users address present with some reward, otherwise an `CodeInsufficientAllowance` error is thrown *)
transition ClaimRewards()
  IsNotEmergencyPaused;
  RewardIfEpoch;
  now <-& BLOCKNUMBER;
  maybe_reward <- reward[_sender];
  match maybe_reward with
    | Some user_reward =>
        MoveFungibleTokenFromXToY contract_to_user reward_token_contract _this_address _sender user_reward;
        delete reward[_sender];
        trl <- total_rewards_left;
        new_trl = builtin sub trl user_reward;
        total_rewards_left := new_trl;
        e = {_eventname : "ClaimRewardsSuccess"; 
            rewarded:_sender; amount:user_reward}; 
        event e
    | None => 
      err = SenderHasNoRewards;
      ThrowError err
  end
end

(* @dev: Allows a user to leave the ssas pool, returning their original stake to them *)
(* @dev: If UserSSAS.block_entered_staking + tax_free_threshold <= BLOCKNUMBER then no tax, else tax current_early_leave_tax% of total_deposit_amount and increment total_taxed_amount *)
(* @dev: Allows withdrawl of inital if soft paused *)
(* @dev: Errors if emergency paused *)
(* @Requirements: *)
(* - `pool[_sender]` should have a users address present otherwise an `SenderHasNoFundsAtContract` error is thrown *)
(* - `tax_amount_as_uint256` has the potential to overflow, if so, a `MathError` error is thrown *)
(* - `withdraw_amount` should be equal to or larger than Uint128 10 otherwise tax cannot be applied *)
transition Withdraw(withdraw_amount: Uint128)
  RewardIfEpoch;
  IsValidAmount withdraw_amount; (* need to withdraw above minimum*)
  maybe_exists <- pool[_sender];
   match maybe_exists with
    | Some some_user_ssas => 
      match some_user_ssas with
        | UserSSAS enter_stake_block currently_deposited_tokens =>
            (* user must be left with more than 10  *) 
            funds_remaining = builtin sub currently_deposited_tokens withdraw_amount;
            IsValidAmountOrZero funds_remaining; (* left with more than 10, or zero *)
            now <-& BLOCKNUMBER;
            min_block_time_no_tax <- current_minimum_lock_time_no_tax;
            tax_free_threshold = builtin badd enter_stake_block min_block_time_no_tax; (* calc tax_free block *)
            is_taxable = builtin blt now tax_free_threshold; (* is now in the past compared to threshold *)
            match is_taxable with
              | True => (* tax current_early_leave_tax% of users deposit *)
                  early_leave_tax_bps <- current_early_leave_tax;
                  x = builtin div tax_bps_max early_leave_tax_bps; 
                  tax_amount_from_withdraw = builtin div withdraw_amount x;
                  currently_deposited_tokens_after_tax = builtin sub withdraw_amount tax_amount_from_withdraw; 
                  (* increase contract allowance for tax *)
                  total_taxed <- total_taxed_amount;
                  new_total_taxed = builtin add total_taxed tax_amount_from_withdraw;
                  total_taxed_amount := new_total_taxed;
                  (* decrease total amount locked by withdraw amount *)
                  amount_locked <- total_amount_locked;
                  new_amount_locked = builtin sub amount_locked withdraw_amount;
                  total_amount_locked:= new_amount_locked;
                  (* move tokens to user *)
                  MoveFungibleTokenFromXToY contract_to_user stake_token_contract _this_address _sender currently_deposited_tokens_after_tax; (* deposit amount. not recalculated addition*)
                  (* remove from pool*)
                  is_zero = builtin eq currently_deposited_tokens withdraw_amount;
                  match is_zero with (* cleanup *)
                    | True => 
                      delete pool[_sender]
                    | False => 
                  end;
                  (* withdraw with tax success *)
                  e = {_eventname : "TaxableWithdrawSuccess"; 
                  you_deposited:currently_deposited_tokens; you_withdrew:currently_deposited_tokens_after_tax; tax_applied:tax_amount_from_withdraw;
                  you_joined_pool_at:enter_stake_block; you_left_at:now; tax_free_period_beyond: tax_free_threshold }; 
                  event e
              | False => (* tax free *)
                  (* decrease total amount locked by withdraw amount *)
                  amount_locked <- total_amount_locked;
                  new_amount_locked = builtin sub amount_locked withdraw_amount;
                  total_amount_locked:= new_amount_locked;
                  (* move tokens to user *)
                  MoveFungibleTokenFromXToY contract_to_user stake_token_contract _this_address _sender withdraw_amount; (* deposit amount. not recalculated addition*)
                  (* remove from pool*)
                  is_zero = builtin eq currently_deposited_tokens withdraw_amount;
                  match is_zero with (* cleanup *)
                    | True => 
                      delete pool[_sender]
                    | False => 
                  end;
                  (* withdraw with tax success *)
                  e = {_eventname : "NonTaxableWithdrawSuccess"; 
                  you_deposited:currently_deposited_tokens; you_withdrew:withdraw_amount; 
                  you_joined_pool_at:enter_stake_block; you_left_at:now}; 
                  event e
            end
        end
  | None =>
    (* user has no stake *)
    err = SenderHasNoFundsAtContract;
    ThrowError err
  end
end

(* @dev: Owner can topup the amount of rewards and extend the contract life.  *)
(* @dev: Errors if soft paused *)
(* @dev: Errors if emergency paused *)
(* @Requirements: *)
(* - `amount` should be a full multiple of the immutable rewards *)
transition OwnerTopUpRewards(topup_amount: Uint128)
  IsContractOwner;
  IsNotEmergencyPaused;
  IsNotSoftPaused;
  RewardIfEpoch;
  rewards_left <- total_rewards_left;
  is_equal = builtin eq topup_amount reward_per_epoch;
  match is_equal with
    | True => (* single epoch *)
      (* top up *)
      MoveFungibleTokenFromXToY user_to_contract reward_token_contract _sender _this_address topup_amount;
      new_rewards_left = builtin add rewards_left topup_amount;
      total_rewards_left:= new_rewards_left;
      (* set expire block = expire + length *)
      rewards_expire <- epochs_rewards_expire;
      new_rewards_expire = builtin badd rewards_expire epoch_calculation_period_length;
      epochs_rewards_expire:= new_rewards_expire;
      (* set amount of epochs deposited *)
      epochs_to_reward <- amount_of_epochs_to_reward;
      epochs_to_reward_plus_one = builtin add epochs_to_reward uint128_one;
      amount_of_epochs_to_reward := epochs_to_reward_plus_one;
      e = {_eventname : "OwnerSingleRewardTopUpSuccess"; amount_topped_up: topup_amount; contract_held: new_rewards_left; deposit_more_funds_at: new_rewards_expire; amount_of_epochs_to_reward:epochs_to_reward_plus_one };
      event e
    | False => (* is mutiple? *)
      x = builtin div topup_amount reward_per_epoch;
      y = builtin div topup_amount x;
      is_multiple = builtin eq y reward_per_epoch;
      match is_multiple with
        | True => (* is mutiple *)
          (* top up *)
          MoveFungibleTokenFromXToY user_to_contract reward_token_contract _sender _this_address topup_amount;
          new_rewards_left = builtin add rewards_left topup_amount;
          total_rewards_left:= new_rewards_left;
          (* set expire block = expire + (x * length) *)
          rewards_expire <- epochs_rewards_expire;
          blocks_to_reward = builtin mul x epoch_calculation_period_length;
          new_rewards_expire = builtin badd rewards_expire blocks_to_reward;
          epochs_rewards_expire:= new_rewards_expire;
          (* set amount of epochs deposited *)
          epochs_to_reward <- amount_of_epochs_to_reward;
          epochs_to_reward_plus_x = builtin add epochs_to_reward x;
          amount_of_epochs_to_reward := epochs_to_reward_plus_x;
          e = {_eventname : "OwnerMutiRewardTopUpSuccess"; amount_topped_up: topup_amount; contract_held: new_rewards_left; blocks_to_reward: blocks_to_reward; x: x; amount_of_epochs_to_reward: epochs_to_reward_plus_x};      
          event e
        | False =>
          err = SentRewardsNotAMutipleOfRewardPerEpoch;
          ThrowError err
      end
  end
end

(* @dev: Owner can change the minimum time that users are impacted by tax, can be zero *)
transition OwnerChangeTaxLockTime(new_min_tax_time_in_blocks: Uint128)
  IsContractOwner;
  RewardIfEpoch;
  current_minimum_lock_time_no_tax := new_min_tax_time_in_blocks;
  e = {_eventname : "OwnerChangeTaxLockTimeSuccess"; new_tax_time: new_min_tax_time_in_blocks};
  event e
end

(* @dev: Allows owner to change the rate in which users are impacted by tax in bps, can be zero, can't be more than 10000 *)
transition OwnerChangeTaxRate(new_tax_rate_in_bps: Uint128) 
  IsContractOwner;
  RewardIfEpoch;
  is_valid_min = uint128_ge new_tax_rate_in_bps tax_bps_min;
  is_valid_max = uint128_lt new_tax_rate_in_bps tax_bps_max; 
  is_valid = andb is_valid_min is_valid_max;
  match is_valid with
    | True =>
      current_early_leave_tax := new_tax_rate_in_bps;
      e = {_eventname : "OwnerChangeTaxRateSuccess"; new_tax_rate: new_tax_rate_in_bps};
      event e
    | False =>
      err = OutOfBoundsTaxBpsValue;
      ThrowError err
  end
end

(* @dev: Allows owner to reclaim total_taxed_amount from contract *)
transition OwnerClaimTax()
  IsContractOwner;
  RewardIfEpoch;
  tta <- total_taxed_amount;
  (* move tax to owner amd update  *)
  MoveFungibleTokenFromXToY contract_to_user stake_token_contract _this_address _sender tta; 
  total_taxed_amount := uint128_zero;
  e = {_eventname : "OwnerClaimTaxSuccess"; tax_sent_to_owner : tta; contract_held_now: uint128_zero};
  event e
end

(* @dev: Contract must be emergency_paused if current_contract_owner wants to reclaim rewards, so that users can't continue to stake for no reward *)
(* @dev: Errors if soft paused *)
(* @dev: Allows withdraws if emergency paused to cater for migration *)
transition OwnerReclaimRewards()
  IsContractOwner;
  IsNotSoftPaused;
  RewardIfEpoch;
  is_paused <- emergency_pause;
  match is_paused with
    | True =>
      trl <- total_rewards_left;
      (* move rewards to owner amd update  *)
      MoveFungibleTokenFromXToY contract_to_user reward_token_contract _this_address _sender trl; 
      total_rewards_left := uint128_zero;
      e = {_eventname : "OwnerReclaimRewardsSuccess"; rewards_taken:trl; contract_held_now: uint128_zero};
      event e
    | False =>
      err = ContractShouldBeEmergencyPaused;
      ThrowError err
  end
end

(* @dev: Allows current_contract_owner to toggle pause all interactions except withdrawals of the initial claim. *)
(* @dev: Implications of an emergency paused contract include all withdraw/deposits transition stop accepting funds *)
transition OwnerToggleEmergencyPause(pause_state: Bool)
  IsContractOwner;
  RewardIfEpoch;
  emergency_pause := pause_state;
  e = {_eventname : "OwnerToggleEmergencyPauseSuccess"; new_pause_state: pause_state};
  event e
end

(* @dev: Allows current_contract_owner to toggle pause all interactions except withdrawals of the initial claim. *)
(* @dev: Implications of an soft paused contract includes stopping accepting new deposits or new rewards, but allows  *)
transition OwnerToggleSoftPause(pause_state: Bool)
  IsContractOwner;
  RewardIfEpoch;
  soft_pause := pause_state;
  e = {_eventname : "OwnerToggleSoftPauseSuccess"; new_pause_state: pause_state};
  event e
end

(* @dev: Current_contract_owner can stage a new staged_contract_owner address *)
transition RequestOwnershipTransfer(new_owner : ByStr20)
  IsContractOwner;
  RewardIfEpoch;
  new_staging = Some {ByStr20} new_owner;
  staged_contract_owner := new_staging;
  e = {_eventname : "RequestOwnershipTransferSuccess"; staged_contract_owner: new_staging};
  event e
end

(* @dev: After a new staged_contract_owner is set, that address can claim ownership *)
transition ConfirmOwnershipTransfer()
  ChangeContractOwnershipIfSenderIsStagingOwner;
  RewardIfEpoch;
  e = {_eventname : "ConfirmOwnershipTransferSuccess"; new_contract_owner: _sender};
  event e
end


transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end