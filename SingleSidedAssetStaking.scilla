scilla_version 0

import IntUtils BoolUtils ListUtils PairUtils

library SingleSidedAssetStaking

let uint128_zero = Uint128 0
let bnum_zero = BNum 0
let empty_bystr = 0x0000000000000000000000000000000000000000

let tax_bps_min = Uint128 1 (* 0.01% *)
let tax_bps_max = Uint128 10000 (* 100% *)

type UserSSAS  =  | UserSSAS of BNum    (* block entered staking *)
                                Uint128 (* deposited tokens *)

type TokenMove = | UserToContract | ContractToUser
let utc        = UserToContract
let ctu        = ContractToUser
 
let one_msg = 
    fun (msg : Message) => 
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg

let two_msgs =
    fun (msg1 : Message) =>
    fun (msg2 : Message) =>
        let msgs_tmp = one_msg msg2 in
        Cons {Message} msg1 msgs_tmp
        
let uint128_to_uint256 : Uint128 -> Uint256 =
  fun (x : Uint128) =>
    let ox256 = builtin to_uint256 x in
      match ox256 with
      | None =>
        (* this never happens, hence we throw a division by zero exception just in case *)
        let zero = Uint256 0 in
        builtin div zero zero
      | Some x256 => x256
      end
         
 (* Compute "(x * y) / z" with protection against integer overflows *)
let muldiv : Uint128 -> Uint128 -> Uint128 -> Uint128 =
    fun (x : Uint128) =>
    fun (y : Uint128) =>
    fun (z : Uint128) =>
      let x256 = uint128_to_uint256 x in
      let y256 = uint128_to_uint256 y in
      let z256 = uint128_to_uint256 z in
      let x_mul_y256 = builtin mul x256 y256 in
      let res256 = builtin div x_mul_y256 z256 in
      let ores128 = builtin to_uint128 res256 in
      match ores128 with
      | None =>
        (* this must never happen, hence we throw an integer overflow exception *)
        let max_uint128 = Uint128 340282366920938463463374607431768211455 in
        let fourtytwo128 = Uint128 42 in
        builtin mul max_uint128 fourtytwo128
      | Some res128 =>
        res128
      end
       
let list_sum =
  fun (l : List (Pair ByStr20 UserSSAS)) =>
    let foldl = @list_foldl (Pair ByStr20 UserSSAS) Uint128 in
    let init = Uint128 0 in
    let iter =
      fun (sum : Uint128) =>
      fun (list_element : Pair ByStr20 UserSSAS) =>
        match list_element with 
        | Pair _ (UserSSAS enter_stake_block currently_deposited_tokens) =>
            builtin add sum currently_deposited_tokens
        end 
    in
    foldl iter init l
(*
  This could be neater / more gas efficent if using key inserts, but functions only allow pure expressions, so we can use put/get here
  This is still a concern for high N. 
  It's possible to estimate worst case gas (I think) from knowing how much calculation does 1 add does with and without calculating eligiblity as that is the most expensive
  calculation because of a map get/put assignment afterwards and then the reassignment. 
  From an inital test I've done
  0 entries, when snapshotting and inserting 1 (minimum) the gas cost is 3.92 ZIL 
  5 entries which are not eligible for rewards, when snapshotted costs 4.118 ZIL @0.002 ZIL GasPrice for also a deposit
  5 entries which are eligible for rewards, when snapshotted costs 4.34 ZIL for a deposit
  we can reason that so far every entry, if eligible needs calcing and adding, would add 0.0444 ZIL per record
  so at 500 entries, at worstcase everyone is eligible the gas price should be at an estimate between 24 and 26 ZIL
  
  side idea - if you get snapshotted, it would be nice to be able to refund someone what the gas cost of the entire operation would be like _gas_cost, 
  but I'm not sure if we can dynamically get that before unwinding the call at the language/blockchain level???
  maybe just send them N tokens instead, then it maybe gamifies claiming on the epoch or at least in the epoch to keep it moving
  then rewards are minus some static insentive to hit the contract
*)



let get_updated_reward_map_if_eligible =
  fun (l : List (Pair ByStr20 UserSSAS)) => (* pool.toList *)
  fun (sum_at_epoch : Uint128) => (* the total of the pool calculated once *)
  fun (now : BNum) => (* now in btime*)
  fun (epoch_length : Uint128) => (* the current epoch length *)
  fun (reward_per_epoch : Uint128) => (* reward to distribute if valid on an epoch*)
  fun (reward_map : Map ByStr20 Uint128) => (*reward.toList*)
    let foldl = @list_foldl 
      (Pair ByStr20 UserSSAS) (* what we are foreaching*)
      (Map ByStr20 Uint128) in (* accumulator what's returned each time *)
    let init = Uint128 0 in
    let iter =
      fun (acc : Map ByStr20 Uint128) => (* whats returned, a list of updated entries, to later add to a map *)
      fun (list_element : Pair ByStr20 UserSSAS) => (* current head list element, iterated through *)
        match list_element with 
        | Pair _ (UserSSAS enter_stake_block currently_deposited_tokens) =>
          let user_address = let fst_string_bystr20 = @fst ByStr20 UserSSAS in fst_string_bystr20 list_element in
          let min_valid_claim = builtin badd enter_stake_block epoch_length in
          let is_past = builtin blt now min_valid_claim in 
            match is_past with
              | False => (* claiming for an eligble staking duration period *)
                    let user_share_of_rewards_at_this_epoch_as_uint256 = muldiv currently_deposited_tokens reward_per_epoch sum_at_epoch in
                    let maybe_user_share_of_rewards_at_this_epoch = builtin to_uint128 user_share_of_rewards_at_this_epoch_as_uint256 in
                    let maybe_previous_reward = builtin get acc user_address in
                          match maybe_previous_reward with
                            | Some previous_reward => (* previously have an entry*)
                                match maybe_user_share_of_rewards_at_this_epoch with
                                  | Some user_share_of_rewards_at_this_epoch =>
                                    let new_total = builtin add previous_reward user_share_of_rewards_at_this_epoch in
                                    builtin put acc user_address new_total 
                                  | None => (* shouldn't get here noop *)
                                    acc
                                end
                            | None => (* first epoch eligible ,create map entry*)
                                match maybe_user_share_of_rewards_at_this_epoch with
                                  | Some user_share_of_rewards_at_this_epoch =>
                                     builtin put acc user_address user_share_of_rewards_at_this_epoch 
                                  | None => (* shouldn't get here noop *)
                                    acc
                                end
                          end
              | True => (* arent eligible noop *)
                acc
              end
          end
    in
    foldl iter reward_map l 

type Error =
  | NotContractOwnerOrStagedOwner
  | SenderHasNoRewards
  | SentRewardsNotAMutipleOfRewardPerEpoch
  | MathError  
  | SenderHasNoFundsAtContract
  | IsPaused
  | StageOwnerNotConfigured

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | NotContractOwnerOrStagedOwner                 => Int32 -1
      | SenderHasNoRewards      => Int32 -2
      | SentRewardsNotAMutipleOfRewardPerEpoch => Int32 -5
      | MathError                => Int32 -6 
      | SenderHasNoFundsAtContract     => Int32 -7
      | IsPaused => Int32 -10
      | StageOwnerNotConfigured => Int32 -11
      end
    in
    { _exception : "Error"; code : result_code; res : result}
    
(*
    EXTRA RESOURCES:
    https://medium.com/paradigm-fund/combining-staking-and-liquidity-provisioning-d30e9d67d713
    https://www.xdaichain.com/for-stakers/easy-staking/emission-rates

    This contract is responsible for holding custody of locked assets and rewarding users for their share for a specific epoch.
    An epoch is defined as a period of time represented by a period of BNums.
    For an epoch, token owners (TO) can determine how many tokens are distributed for a given epoch.
    For an epoch, users can earn a percentage share dependant on their share of the locker. 
    Given that a token owner deposits rewards, these SSAS contracts are temporary and finite, unless 'TO' continues to deposit the underlying.
    TO set's a minimum lock duration that allows for 0% fee withdrawals (7d default) - Users can withdraw instantly before 7d for a fee in tokens (10% default).
    The reward rate is dynamic and varies depending on:
    The number of tokens a user has & the number of tokens the pool has.
    Users may claim a reward for a previously elapsed epoch they were present in. Users may not claim a reward for an epoch in progress. 

*)
contract SingleSidedAssetStaking
(
  inital_contract_owner: ByStr20,
  token_contract: ByStr20 with contract end, 
  reward_token_contract: ByStr20 with contract end,
  epoch_period_length: Uint128, (* ~2500bpd * 7d = 17500b as uint *)
  early_leave_tax: Uint128,     (* 10 = 1000 *)
  immutable_reward_per_epoch: Uint128  (* rewarded in total per epoch *) (* immutable *)
)
with
  let calculated_start_epoch = builtin badd _creation_block epoch_period_length in (* ideally next_epoch_block:= calculated_start_epoch *)
  let is_valid_min = uint128_gt early_leave_tax tax_bps_min in
  let is_valid_max = uint128_lt early_leave_tax tax_bps_max in 
  let is_valid = andb is_valid_min is_valid_max in
  match is_valid with 
      | True =>
           True
      | False =>
          False
  end 
=>

field paused: Bool = False (* stops deposits/claimrewards but not withdraws *)
field current_contract_owner: ByStr20  = inital_contract_owner (* owner of admin functions *)
field staged_contract_owner: Option ByStr20 = None {ByStr20} (* owner can surrender ownership to an address. 2 step: stage, confirm to set a new current_owner*)

field total_taxed_amount: Uint128 = uint128_zero  (* totals the amount taxed, allows current_owner to withdraw *)
field total_amount_locked: Uint128 = uint128_zero (* total amount locked by users *)
field total_rewards_left: Uint128 = uint128_zero (* total amount of rewards deposited able to be claimed in the future, can be topped-up *)
field current_early_leave_tax: Uint128 = early_leave_tax (* mutable tax rate on leaving pool before an epoch duration *)

field current_epoch_length: Uint128 = epoch_period_length (* length of an epoch in blocks represented as Uint128 *)
field next_epoch_block: BNum = _creation_block  (* when should first epoch time be = time_at_deployment+epoch_length*)

field pool: Map ByStr20 UserSSAS = Emp ByStr20 UserSSAS (* user_address -> (enter_stake_block, deposited_tokens *) (* stores users deposits*)
field reward: Map ByStr20 Uint128 = Emp ByStr20 Uint128 (* user_address-> earnt_accum_reward *) (* calculates dynamically reward over time*)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsContractOwner()
  cco <- current_contract_owner;
  is_contract_owner = builtin eq cco _sender;
    match is_contract_owner with
      | True => 
      | False =>
        err = NotContractOwnerOrStagedOwner;
        ThrowError err
    end
end

procedure ChangeContractOwnershipIfSenderIsStagingOwner()
  maybe_staged_contract_owner <- staged_contract_owner;
  match maybe_staged_contract_owner with
  | Some sca =>
      caller_is_staged_owner = builtin eq _sender sca;
      match caller_is_staged_owner with
      | True =>
          current_contract_owner := sca;
          reset_staged_owner = None {ByStr20};
          staged_contract_owner := reset_staged_owner
      | False =>
        err = NotContractOwnerOrStagedOwner;
        ThrowError err
      end
  | None =>  
    err = StageOwnerNotConfigured;
    ThrowError err
  end 
end

procedure IsNotPaused()
  is_paused <- paused;
  match is_paused with
    | True => 
      err = IsPaused;
      ThrowError err
    | False =>
  end
end

(* moves amount of token contract ft from x to y. *)
procedure MoveFungibleTokenFromXToY(token_move: TokenMove, fungible_contract:ByStr20 with end, from: ByStr20, to: ByStr20, amount: Uint128)
  match token_move with
    | UserToContract =>
        transfer_to_contract = {
          _tag: "TransferFrom";
          _recipient: fungible_contract;
          _amount: uint128_zero;
          from: from;
          to: to;
          amount: amount
          };
        msgs = one_msg transfer_to_contract;
        send msgs
        
    | ContractToUser =>
        transfer_to_user = {
          _tag: "Transfer";
          _recipient: fungible_contract;
          _amount: uint128_zero;
          to: to;
          amount: amount
        };
        msgs = one_msg transfer_to_user;
        send msgs
    end
end

procedure RewardIfEpoch()
  now <-& BLOCKNUMBER;
  neb <- next_epoch_block;
  is_future = builtin blt neb now;  (* is the current block less than the snapshot (the past, will be true on the value of nsbr+1 and future blocks) *)
  match is_future with
    | True => (* now+1 and future blocks *)
      (* caters for the case where epochs lag behind carries right upto now, so epochs can be longer than epl but the next tx catches it up *)
      (* this will also completely skip epochs if missed, so really a high block count for the epoch is needed to counteract this. *)
      new_neb = builtin badd now epoch_period_length; 
      reward_map <- reward;
      pool_map <- pool;
      pool_to_list = builtin to_list pool_map;
      sum_at_epoch = list_sum pool_to_list;
      
      new_reward_map = get_updated_reward_map_if_eligible pool_to_list sum_at_epoch now epoch_period_length immutable_reward_per_epoch reward_map;
      reward:=  new_reward_map;
      next_epoch_block:= new_neb; 

      e = {_eventname : "SnapshotSuccess"; 
           now:now; processed_epoch:neb; next_epoch: new_neb };
      event e

    | False => (* the past *)
      blocks_till_trigger = builtin bsub now neb;
      e = {_eventname : "NotSnapshotTime";
           now: now; next_epoch:neb; blocks_till_trigger:blocks_till_trigger
      };
      event e
  end
end

(*
  Allows a user to deposit an amount of tokens into the contract
  On increasing an already existing deposit, a new tax_threshold block is generated and you restart your tax-free duration starting from this_block
*)
transition Deposit(deposit_amount: Uint128)
  IsNotPaused;
  now <-& BLOCKNUMBER;
  maybe_exists <- pool[_sender];
  cel <- current_epoch_length;
  tal <- total_amount_locked;
  deposit_lock_duration = builtin badd now cel;
  
  match maybe_exists with
    | Some some_user_ssas => (* user already exists, increase amount of tokens *)
      match some_user_ssas with
        | UserSSAS enter_stake_block currently_deposited_tokens =>
          
            new_deposited_tokens = builtin add currently_deposited_tokens deposit_amount;
            user_ssas = UserSSAS deposit_lock_duration    (* new lock duration            *)
                                 new_deposited_tokens;    (* addition to tokens staked    *)
            
            (* move tokens to contract *)
            MoveFungibleTokenFromXToY utc token_contract _sender _this_address deposit_amount; (* deposit amount. not recalculated addition*)
            
            pool[_sender] := user_ssas;
            new_tal = builtin add tal deposit_amount;
            total_amount_locked := new_tal;
            
            e = {_eventname : "IncreasingDepositSuccess"; user_ssas : user_ssas };
            event e
            
        end
    | None => (* user doesn't exist, initalise ssas *)
    
      user_ssas = UserSSAS deposit_lock_duration (* new lock duration     *)
                           deposit_amount;    (* inital deposit amount *)
                           
      MoveFungibleTokenFromXToY utc token_contract _sender _this_address deposit_amount;
            
      pool[_sender] := user_ssas;
      new_tal = builtin add tal deposit_amount;
      total_amount_locked := new_tal;
      
      e = {_eventname : "InitalDepositSuccess"; user_ssas : user_ssas };
      event e
  end;
  RewardIfEpoch (* for a deposit this needs to go at the end, so that any eligible users, if depositing and is the epoch snapshot, become ineligible
                   after the block time is updated *)
end


(*
  Given a user claims for some rewards
  Examine ssas_pool.UserSSAS.enter_stake_block 
*)
transition ClaimRewards()
  IsNotPaused;
  RewardIfEpoch;
  now <-& BLOCKNUMBER;
  maybe_reward <- reward[_sender];
  match maybe_reward with
    | Some user_reward =>
        MoveFungibleTokenFromXToY ctu reward_token_contract _this_address _sender user_reward;
        e = {_eventname : "ClaimRewardsSuccess"; 
            rewarded:_sender; amount:user_reward}; 
        event e
    | None => 
      err = SenderHasNoRewards;
      ThrowError err
  end
end

(*
    Allows a user to leave the ssas pool
    If UserSSAS.block_entered_staking + epoch_period_length <= BLOCKNUMBER  (no tax)
    else tax 10% of total_deposit_amount and increment total_taxed_amount
    remove this from the real pool
    allows withdrawls if paused
*)
transition Withdraw()
  RewardIfEpoch;
  maybe_exists <- pool[_sender];
   match maybe_exists with
    | Some some_user_ssas => 
      match some_user_ssas with
        | UserSSAS enter_stake_block currently_deposited_tokens =>
            now <-& BLOCKNUMBER;
            cel <- current_epoch_length;
            tax_free_threshold = builtin badd enter_stake_block cel; (* calc tax_free block *)
            is_taxable = builtin blt now tax_free_threshold; (* is now in the past compared to threshold *)
            match is_taxable with
              | True => 
                (* tax 10% of users deposit *)
                early_leave_tax_bps <- current_early_leave_tax;
                x = builtin div tax_bps_max early_leave_tax_bps; 
                tax_amount_as_uint256 = builtin div currently_deposited_tokens x; (* simplify with muldiv *)
                maybe_tax_amount = builtin to_uint128 tax_amount_as_uint256;
                match maybe_tax_amount with 
                 | Some tax_amount => 
                    (* calculate tax *)
                    currently_deposited_tokens_after_tax = builtin sub currently_deposited_tokens tax_amount; 
                    (* increase contract allowance for tax *)
                    txa <- total_taxed_amount;
                    new_txa = builtin add txa tax_amount;
                    total_taxed_amount:= new_txa;
                    (* decrease total amount locked by withdraw amount *)
                    tal <- total_amount_locked;
                    new_tal = builtin sub tal currently_deposited_tokens_after_tax;
                    total_amount_locked:= new_tal;
                    (* move tokens to user *)
                    MoveFungibleTokenFromXToY ctu token_contract _this_address _sender currently_deposited_tokens_after_tax; (* deposit amount. not recalculated addition*)
                    (* remove from pool*)
                    delete pool[_sender];
                    (* withdraw with tax success *)
                    e = {_eventname : "TaxableWithdrawSuccess"; 
                    you_deposited:currently_deposited_tokens; you_withdrew:currently_deposited_tokens_after_tax; tax_applied:tax_amount;
                    you_joined_pool_at:enter_stake_block; you_left_at:now; you_should_have_left_at: tax_free_threshold }; 
                    event e
                 | None => (* Some math overflow error*)
                 err = MathError;
                 ThrowError err
                end 
              | False => (* tax free *)
                (* decrease total amount locked by withdraw amount *)
                tal <- total_amount_locked;
                new_tal = builtin sub tal currently_deposited_tokens;
                total_amount_locked:= new_tal;
                (* move tokens to user *)
                MoveFungibleTokenFromXToY ctu token_contract _this_address _sender currently_deposited_tokens; (* deposit amount. not recalculated addition*)
                (* remove from pool*)
                delete pool[_sender];
                (* withdraw with tax success *)
                e = {_eventname : "NonTaxableWithdrawSuccess"; 
                you_deposited:currently_deposited_tokens; you_withdrew:currently_deposited_tokens; 
                you_joined_pool_at:enter_stake_block; you_left_at:now}; 
                event e
            end
      end
    | None =>
      (* user has no stake *)
      err = SenderHasNoFundsAtContract;
      ThrowError err
  end
end

(*
  Admin can topup rewards and extend contract life if it's a full multiple of the immutable rewards 
*)
transition OwnerTopUpRewards(amount: Uint128)
  IsContractOwner;
  RewardIfEpoch;
  (* use reward_per_epoch to check if the incoming amount is a mutiple, otherwise people will get mad *)
  trl <- total_rewards_left;
  (*
    modulus_rewards = builtin rem immutable_reward_per_epoch amount;
    is_perfect_division = builtin eq modulus_rewards uint128_zero; 
  *)
  (* move reward to contract and update *)
  MoveFungibleTokenFromXToY utc reward_token_contract _sender _this_address amount;
  new_rewards_left = builtin add trl amount;
  total_rewards_left:= new_rewards_left;
  e = {_eventname : "AdminSentRewardsSuccess"; amount_sent : amount; contract_held: new_rewards_left};
  event e
end

(*
  allows admin to reclaim total_taxed_amount (tax = tokens)
*)
transition OwnerReclaimTax()
  IsContractOwner;
  RewardIfEpoch;
  tta <- total_taxed_amount;
  (* move tax to admin amd update  *)
  MoveFungibleTokenFromXToY ctu token_contract _this_address _sender tta; 
  total_taxed_amount:= uint128_zero;
  e = {_eventname : "AdminClaimedTaxSuccess"; tax_sent_to_admin : tta; contract_held_now: uint128_zero};
  event e
end

(*
  contract must be paused if current_contract_owner wants to claim rewards (rewards = reward_token_contract) so that users can't
*)
transition OwnerReclaimRewards()
  IsContractOwner;
  RewardIfEpoch;
  is_paused <- paused;
  match is_paused with
    | True =>
      trl <- total_rewards_left;
      (* move tax to admin amd update  *)
      MoveFungibleTokenFromXToY ctu reward_token_contract _this_address _sender trl; 
      total_rewards_left:= uint128_zero;
      e = {_eventname : "AdminClaimRewardsSuccess"; rewards_taken:trl; contract_held_now: uint128_zero};
      event e
    | False =>
  end
end

(*
  allows current_contract_owner to toggle pause all interactions expect withdraws of inital (pauses withdraw of rewards)
*)
transition OwnerTogglePause(pause_state: Bool)
  IsContractOwner;
  RewardIfEpoch;
  paused:=pause_state;
  e = {_eventname : "OwnerTogglePauseSuccess"; new_pause_state: pause_state};
  event e
end

(*
  current_contract_owner can stage a new staged_contract_admin address
*)
transition RequestOwnershipTransfer(new_owner : ByStr20)
  IsContractOwner;
  RewardIfEpoch;
  sca = Some {ByStr20} new_owner;
  staged_contract_owner := sca;
  e = {_eventname : "RequestOwnershipTransferSuccess"; staged_contract_owner: sca};
  event e
end

(*
  after a new staged_contract_admin address is set, that address can claim ownership
*)
transition ConfirmOwnershipTransfer()
  ChangeContractOwnershipIfSenderIsStagingOwner;
  RewardIfEpoch;
  e = {_eventname : "ConfirmOwnershipTransferSuccess"; new_contract_owner: _sender};
  event e
end

(*
  after a new staged_contract_admin address is set, the current_contract_owner can revoke this 
*)
transition RevokeOwnershipTransfer()
  IsContractOwner;
  RewardIfEpoch;
  reset_staged_owner = None {ByStr20};
  staged_contract_owner := reset_staged_owner;
  e = {_eventname : "RevokeDelegatorSwapSuccess"; revoked_by_owner: _sender};
  event e
end


transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end