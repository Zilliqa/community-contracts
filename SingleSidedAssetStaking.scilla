scilla_version 0

import IntUtils BoolUtils ListUtils PairUtils

library SingleSidedAssetStaking

let uint128_zero = Uint128 0
let bnum_zero = BNum 0
let empty_bystr = 0x0000000000000000000000000000000000000000
let tax_bps_min = Uint128 1 (* 0.01% *)
let tax_bps_max = Uint128 10000 (* 100% *)

type UserSSAS  =  | UserSSAS of BNum    (* block entered staking *)
                                Uint128 (* deposited tokens *)

type TokenMove = | UserToContract | ContractToUser
let utc        = UserToContract
let ctu        = ContractToUser
 
let one_msg = 
    fun (msg : Message) => 
        let nil_msg = Nil {Message} in
        Cons {Message} msg nil_msg

let two_msgs =
    fun (msg1 : Message) =>
    fun (msg2 : Message) =>
        let msgs_tmp = one_msg msg2 in
        Cons {Message} msg1 msgs_tmp
        
let uint128_to_uint256 : Uint128 -> Uint256 =
  fun (x : Uint128) =>
    let ox256 = builtin to_uint256 x in
      match ox256 with
      | None =>
        (* this never happens, hence we throw a division by zero exception just in case *)
        let zero = Uint256 0 in
        builtin div zero zero
      | Some x256 => x256
      end
         
 (* Compute "(x * y) / z" with protection against integer overflows *)
let muldiv : Uint128 -> Uint128 -> Uint128 -> Uint128 =
    fun (x : Uint128) =>
    fun (y : Uint128) =>
    fun (z : Uint128) =>
      let x256 = uint128_to_uint256 x in
      let y256 = uint128_to_uint256 y in
      let z256 = uint128_to_uint256 z in
      let x_mul_y256 = builtin mul x256 y256 in
      let res256 = builtin div x_mul_y256 z256 in
      let ores128 = builtin to_uint128 res256 in
      match ores128 with
      | None =>
        (* this must never happen, hence we throw an integer overflow exception *)
        let max_uint128 = Uint128 340282366920938463463374607431768211455 in
        let fourtytwo128 = Uint128 42 in
        builtin mul max_uint128 fourtytwo128
      | Some res128 =>
        res128
      end
        
let list_sum_if_eligible =
  fun (l : List (Pair ByStr20 UserSSAS)) =>
  fun (epoch_length : Uint128) => (* the current epoch length *)
  fun (now : BNum) => (* now in btime*)
    let foldl = @list_foldl (Pair ByStr20 UserSSAS) Uint128 in
    let init = Uint128 0 in
    let iter =
      fun (sum : Uint128) =>
      fun (list_element : Pair ByStr20 UserSSAS) =>
        match list_element with 
        | Pair _ (UserSSAS enter_stake_block currently_deposited_tokens) =>
          let user_address = let fst_string_bystr20 = @fst ByStr20 UserSSAS in fst_string_bystr20 list_element in
          let min_valid_claim = builtin badd enter_stake_block epoch_length in
          let is_past = builtin blt now min_valid_claim in 
            match is_past with
              | False => (* claiming for an eligble staking duration period *)
                 builtin add sum currently_deposited_tokens
              | True =>
                sum
            end
        end 
    in
    foldl iter init l
          
(*
  This could be neater / more gas efficent if using key inserts, but functions only allow pure expressions, so we can use put/get here
  This is still a concern for high N. 
  It's possible to estimate worst case gas (I think) from knowing how much calculation does 1 add does with and without calculating eligiblity as that is the most expensive
  calculation because of a map get/put assignment afterwards and then the reassignment. 
  From an inital test I've done
  0 entries, when snapshotting and inserting 1 (minimum) the gas cost is 3.92 ZIL 
  5 entries which are not eligible for rewards, when snapshotted costs 4.118 ZIL @0.002 ZIL GasPrice for also a deposit
  5 entries which are eligible for rewards, when snapshotted costs 4.34 ZIL for a deposit
  we can reason that so far every entry, if eligible needs calcing and adding, would add 0.0444 ZIL per record
  so at 500 entries, at worstcase everyone is eligible the gas price should be at an estimate between 24 and 26 ZIL
  
  side idea - if you get snapshotted, it would be nice to be able to refund someone what the gas cost of the entire operation would be like _gas_cost, 
  but I'm not sure if we can dynamically get that before unwinding the call at the language/blockchain level???
  maybe just send them N tokens instead, then it maybe gamifies claiming on the epoch or at least in the epoch to keep it moving
  then rewards are minus some static insentive to hit the contract
*)

let get_updated_reward_map_if_eligible =
  fun (l : List (Pair ByStr20 UserSSAS)) => (* pool.toList *)
  fun (sum_at_epoch : Uint128) => (* the total of the pool calculated once *)
  fun (now : BNum) => (* now in btime*)
  fun (epoch_length : Uint128) => (* the current epoch length *)
  fun (reward_per_epoch : Uint128) => (* reward to distribute if valid on an epoch*)
  fun (reward_map : Map ByStr20 Uint128) => (*reward.toList*)
    let foldl = @list_foldl 
      (Pair ByStr20 UserSSAS) (* what we are foreaching*)
      (Map ByStr20 Uint128) in (* accumulator what's returned each time *)
    let init = Uint128 0 in
    let iter =
      fun (acc : Map ByStr20 Uint128) => (* whats returned, an updated map of entries *)
      fun (list_element : Pair ByStr20 UserSSAS) => (* current head list element, iterated through *)
        match list_element with 
        | Pair _ (UserSSAS enter_stake_block currently_deposited_tokens) =>
          let user_address = let fst_string_bystr20 = @fst ByStr20 UserSSAS in fst_string_bystr20 list_element in
          let min_valid_claim = builtin badd enter_stake_block epoch_length in
          let is_past = builtin blt now min_valid_claim in 
            match is_past with
              | False => (* claiming for an eligble staking duration period *)
                    let user_share_of_rewards_at_this_epoch_as_uint256 = muldiv currently_deposited_tokens reward_per_epoch sum_at_epoch in
                    let maybe_user_share_of_rewards_at_this_epoch = builtin to_uint128 user_share_of_rewards_at_this_epoch_as_uint256 in
                    let maybe_previous_reward = builtin get acc user_address in
                          match maybe_previous_reward with
                            | Some previous_reward => (* previously have an entry*)
                                match maybe_user_share_of_rewards_at_this_epoch with
                                  | Some user_share_of_rewards_at_this_epoch =>
                                    let new_total = builtin add previous_reward user_share_of_rewards_at_this_epoch in
                                    builtin put acc user_address new_total 
                                  | None => (* shouldn't get here noop *)
                                    acc
                                end
                            | None => (* first epoch eligible ,create map entry*)
                                match maybe_user_share_of_rewards_at_this_epoch with
                                  | Some user_share_of_rewards_at_this_epoch =>
                                     builtin put acc user_address user_share_of_rewards_at_this_epoch 
                                  | None => (* shouldn't get here noop *)
                                    acc
                                end
                          end
              | True => (* arent eligible noop *)
                acc
              end
          end
    in
    foldl iter reward_map l 

type Error =
  | NotContractOwner  
  | NotStagingOwner
  | StagingOwnerNotConfigured 
  | SenderHasNoRewards
  | SenderHasNoFundsAtContract
  | SentRewardsNotAMutipleOfRewardPerEpoch
  | MathError
  | ContractIsPaused

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | NotContractOwner                              => Int32 -1
      | NotStagingOwner                               => Int32 -2
      | StagingOwnerNotConfigured                     => Int32 -3
      | SenderHasNoRewards                            => Int32 -4
      | SenderHasNoFundsAtContract                    => Int32 -5
      | SentRewardsNotAMutipleOfRewardPerEpoch        => Int32 -6
      | MathError                                     => Int32 -7 
      | ContractIsPaused                              => Int32 -8

      end
    in
    { _exception : "Error"; code : result_code; res : result}
    

contract SingleSidedAssetStaking
(
  inital_contract_owner: ByStr20,
  stake_token_contract: ByStr20 with contract end, 
  reward_token_contract: ByStr20 with contract end,
  epoch_calculation_period_length: Uint128, (* ~2500bpd * 7d = 17500b as uint - time to rewards *)
  minimum_lock_time_no_tax: Uint128, (* 3d as uint - time to leave with no tax *)
  early_leave_tax: Uint128,     (* 10% = 1000bps *)
  immutable_reward_per_epoch: Uint128  (* rewarded in total per epoch *)
)
with
  let is_valid_min = uint128_gt early_leave_tax tax_bps_min in
  let is_valid_max = uint128_lt early_leave_tax tax_bps_max in 
  andb is_valid_min is_valid_max 
=>

field paused: Bool = False (* stops deposits/claimrewards but not withdraws *)
field current_contract_owner: ByStr20  = inital_contract_owner (* owner of owner functions *)
field staged_contract_owner: Option ByStr20 = None {ByStr20} (* owner can surrender ownership to an address. 2 step: stage, confirm to set a new current_owner*)

field total_taxed_amount: Uint128 = uint128_zero  (* totals the amount taxed, allows current_owner to withdraw *)
field total_amount_locked: Uint128 = uint128_zero (* total amount locked by users *)
field total_rewards_left: Uint128 = uint128_zero (* total amount of rewards deposited able to be claimed in the future, can be topped-up *)
field current_early_leave_tax: Uint128 = early_leave_tax (* mutable tax rate on leaving pool before an epoch duration *)
field current_minimum_lock_time_no_tax: Uint128 = minimum_lock_time_no_tax (* mutable minimum time to leave pool without being taxed*)
field current_epoch_length: Uint128 = epoch_calculation_period_length (* length of an epoch in blocks represented as Uint128 *)
field next_epoch_block: BNum = builtin badd _creation_block epoch_calculation_period_length (* when should first epoch time be = time_at_deployment+epoch_length*)

field pool: Map ByStr20 UserSSAS = Emp ByStr20 UserSSAS (* user_address -> (enter_stake_block, deposited_tokens *) (* stores users deposits*)
field reward: Map ByStr20 Uint128 = Emp ByStr20 Uint128 (* user_address-> earnt_accum_reward *) (* calculates dynamically reward over time*)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure IsContractOwner()
  cco <- current_contract_owner;
  is_contract_owner = builtin eq cco _sender;
    match is_contract_owner with
      | True => 
      | False =>
        err = NotContractOwner;
        ThrowError err
    end
end

procedure ChangeContractOwnershipIfSenderIsStagingOwner()
  maybe_staged_contract_owner <- staged_contract_owner;
  match maybe_staged_contract_owner with
  | Some staged_contract_owner =>
      caller_is_staged_owner = builtin eq _sender staged_contract_owner;
      match caller_is_staged_owner with
      | True =>
          current_contract_owner := staged_contract_owner;
          reset_staged_owner = None {ByStr20};
          staged_contract_owner := reset_staged_owner
      | False =>
        err = NotStagingOwner;
        ThrowError err
      end
  | None =>  
    err = StagingOwnerNotConfigured;
    ThrowError err
  end 
end

procedure IsNotPaused()
  is_paused <- paused;
  match is_paused with
    | True => 
      err = ContractIsPaused;
      ThrowError err
    | False =>
  end
end

(* @dev: Move an amount of fungible tokens from a particular contract either to the user or from the user *)
(* @Requirements: *)
(* - `fungible_contract` should have an allowance with this contract address otherwise an `CodeInsufficientAllowance` error is thrown *)
(* - `amount` should have an equal to or less spender allowance otherwise an `CodeInsufficientFunds` error is thrown *)
procedure MoveFungibleTokenFromXToY(token_move: TokenMove, fungible_contract:ByStr20 with end, from: ByStr20, to: ByStr20, amount: Uint128)
  match token_move with
    | UserToContract =>
        transfer_to_contract = {
          _tag: "TransferFrom";
          _recipient: fungible_contract;
          _amount: uint128_zero;
          from: from;
          to: to;
          amount: amount
          };
        msgs = one_msg transfer_to_contract;
        send msgs
    | ContractToUser =>
        transfer_to_user = {
          _tag: "Transfer";
          _recipient: fungible_contract;
          _amount: uint128_zero;
          to: to;
          amount: amount
        };
        msgs = one_msg transfer_to_user;
        send msgs
    end
end

(* @dev: Triggered when now >= next_epoch_block. If eligible, dynamically calculates and sets users rewards for an epoch into 'reward'  *)
(* @Requirements: *)
(* To be eligible for rewards when this is ran. Users have to be deposted for (enter_stake_block + epoch_length) *)
procedure RewardIfEpoch()
  now <-& BLOCKNUMBER;
  epoch_block <- next_epoch_block;
  epoch_length <- current_epoch_length;
  is_time_to_reward = builtin blt epoch_block now;  
  match is_time_to_reward with
    | True => (* now+1 and future blocks *)
      (* caters for the case where epochs lag behind carries right upto now, so epochs can be longer than epl but the next tx catches it up *)
      (* this will also completely skip epochs if missed, so really a high block count for the epoch is needed to counteract this. *)
      new_epoch_block = builtin badd now epoch_length; 
      reward_map <- reward;
      pool_map <- pool;
      pool_to_list = builtin to_list pool_map;
      sum_at_epoch = list_sum_if_eligible pool_to_list epoch_length now; 
      new_reward_map = get_updated_reward_map_if_eligible pool_to_list sum_at_epoch now epoch_length immutable_reward_per_epoch reward_map;
      reward := new_reward_map;
      next_epoch_block := new_epoch_block; 
      e = {_eventname : "SnapshotSuccess"; 
           now:now; processed_epoch:epoch_block; next_epoch: new_epoch_block };
      event e
    | False => (* the past *)
      blocks_till_trigger = builtin bsub now epoch_block;
      e = {_eventname : "NotSnapshotTime";
           now: now; next_epoch:epoch_block; blocks_till_trigger:blocks_till_trigger
      };
      event e
  end
end

(* @dev: Allows a user to deposit an amount of tokens into the contract *)
(* @dev: On increasing an already existing deposit, a new tax_threshold block is generated and you restart your tax-free duration starting from this_block *)
(* @Requirements: *)
(* - `fungible_contract` should have an allowance with this contract address otherwise an `CodeInsufficientAllowance` error is thrown *)
(* - `deposit_amount` should have an equal to or less spender allowance otherwise an `CodeInsufficientFunds` error is thrown *)
transition Deposit(deposit_amount: Uint128)
  IsNotPaused;
  now <-& BLOCKNUMBER;
  maybe_exists <- pool[_sender];
  epoch_length <- current_epoch_length;
  amount_locked <- total_amount_locked;
  deposit_lock_duration = builtin badd now epoch_length;
  match maybe_exists with
    | Some some_user_ssas => (* user already exists, increase amount of tokens *)
      match some_user_ssas with
        | UserSSAS enter_stake_block currently_deposited_tokens =>
          
            new_deposited_tokens = builtin add currently_deposited_tokens deposit_amount;
            user_ssas = UserSSAS deposit_lock_duration    (* new lock duration            *)
                                 new_deposited_tokens;    (* addition to tokens staked    *)
            
            (* move tokens to contract *)
            MoveFungibleTokenFromXToY utc stake_token_contract _sender _this_address deposit_amount; (* deposit amount. not recalculated addition*)
            
            pool[_sender] := user_ssas;
            new_amount_locked = builtin add amount_locked deposit_amount;
            total_amount_locked := new_amount_locked;
            e = {_eventname : "IncreasingDepositSuccess"; user_ssas : user_ssas };
            event e
        end
    | None => (* user doesn't exist, initalise ssas *)
      user_ssas = UserSSAS deposit_lock_duration (* new lock duration     *)
                           deposit_amount;       (* inital deposit amount *)
                           
      MoveFungibleTokenFromXToY utc stake_token_contract _sender _this_address deposit_amount;
            
      pool[_sender] := user_ssas;
      new_amount_locked = builtin add amount_locked deposit_amount;
      total_amount_locked := new_amount_locked;
      e = {_eventname : "InitalDepositSuccess"; user_ssas : user_ssas };
      event e
  end;
  RewardIfEpoch (* for a deposit this needs to go at the end, so that any eligible users, if depositing and is the epoch snapshot, become ineligible after the block time is updated *)
end

(* @dev: Allows a user to claim all accumulated rewards they are eligible for *)
(* @Requirements: *)
(* - `reward[_sender]` should have a users address present with some reward, otherwise an `CodeInsufficientAllowance` error is thrown *)
transition ClaimRewards()
  IsNotPaused;
  RewardIfEpoch;
  now <-& BLOCKNUMBER;
  maybe_reward <- reward[_sender];
  match maybe_reward with
    | Some user_reward =>
        MoveFungibleTokenFromXToY ctu reward_token_contract _this_address _sender user_reward;
        delete reward[_sender];
        trl <- total_rewards_left;
        new_trl = builtin sub trl user_reward;
        total_rewards_left := new_trl;
        e = {_eventname : "ClaimRewardsSuccess"; 
            rewarded:_sender; amount:user_reward}; 
        event e
    | None => 
      err = SenderHasNoRewards;
      ThrowError err
  end
end

(* @dev: Allows a user to leave the ssas pool, returning their original stake to them *)
(* @dev: If UserSSAS.block_entered_staking + tax_free_threshold <= BLOCKNUMBER then no tax, else tax 10% of total_deposit_amount and increment total_taxed_amount *)
(* @dev: Allows withdrawls if paused *)
(* @Requirements: *)
(* - `pool[_sender]` should have a users address present otherwise an `SenderHasNoFundsAtContract` error is thrown *)
(* - `tax_amount_as_uint256` has the potential to overflow, if so, a `MathError` error is thrown *)
(* - `withdraw_amount` should be equal to or larger than Uint128 10 otherwise tax cannot be applied *)
(* - ``, otherwise an `SenderHasNoFundsAtContract` error is thrown *)
transition Withdraw(withdraw_amount: Uint128)
  RewardIfEpoch;
  maybe_exists <- pool[_sender];
   match maybe_exists with
    | Some some_user_ssas => 
      match some_user_ssas with
        | UserSSAS enter_stake_block currently_deposited_tokens =>
            now <-& BLOCKNUMBER;
            min_block_time_no_tax <- current_minimum_lock_time_no_tax;
            tax_free_threshold = builtin badd enter_stake_block min_block_time_no_tax; (* calc tax_free block *)
            is_taxable = builtin blt now tax_free_threshold; (* is now in the past compared to threshold *)
            match is_taxable with
              | True => (* tax 10% of users deposit *)
                early_leave_tax_bps <- current_early_leave_tax;
                x = builtin div tax_bps_max early_leave_tax_bps; 
                tax_amount_as_uint256 = builtin div withdraw_amount x;
                maybe_tax_amount = builtin to_uint128 tax_amount_as_uint256;
                match maybe_tax_amount with 
                 | Some tax_amount => (* calculate tax *)
                    currently_deposited_tokens_after_tax = builtin sub withdraw_amount tax_amount; 
                    (* increase contract allowance for tax *)
                    total_taxed <- total_taxed_amount;
                    new_total_taxed = builtin add total_taxed tax_amount;
                    total_taxed_amount := new_total_taxed;
                    (* decrease total amount locked by withdraw amount *)
                    amount_locked <- total_amount_locked;
                    new_amount_locked = builtin sub amount_locked currently_deposited_tokens_after_tax;
                    total_amount_locked:= new_amount_locked;
                    (* move tokens to user *)
                    MoveFungibleTokenFromXToY ctu stake_token_contract _this_address _sender currently_deposited_tokens_after_tax; (* deposit amount. not recalculated addition*)
                    (* remove from pool*)
                    is_zero = builtin eq currently_deposited_tokens withdraw_amount;
                    match is_zero with (* cleanup *)
                      | True => 
                        delete pool[_sender]
                      | False => 
                    end;
                    (* withdraw with tax success *)
                    e = {_eventname : "TaxableWithdrawSuccess"; 
                    you_deposited:currently_deposited_tokens; you_withdrew:currently_deposited_tokens_after_tax; tax_applied:tax_amount;
                    you_joined_pool_at:enter_stake_block; you_left_at:now; you_should_have_left_at: tax_free_threshold }; 
                    event e
                 | None => (* Some math overflow error*)
                 err = MathError;
                 ThrowError err
                end 
              | False => (* tax free *)
                (* decrease total amount locked by withdraw amount *)
                amount_locked <- total_amount_locked;
                new_amount_locked = builtin sub amount_locked withdraw_amount;
                total_amount_locked:= new_amount_locked;
                (* move tokens to user *)
                MoveFungibleTokenFromXToY ctu stake_token_contract _this_address _sender withdraw_amount; (* deposit amount. not recalculated addition*)
                (* remove from pool*)
                is_zero = builtin eq currently_deposited_tokens withdraw_amount;
                match is_zero with (* cleanup *)
                  | True => 
                    delete pool[_sender]
                  | False => 
                end;
                (* withdraw with tax success *)
                e = {_eventname : "NonTaxableWithdrawSuccess"; 
                you_deposited:currently_deposited_tokens; you_withdrew:withdraw_amount; 
                you_joined_pool_at:enter_stake_block; you_left_at:now}; 
                event e
            end
      end
    | None =>
      (* user has no stake *)
      err = SenderHasNoFundsAtContract;
      ThrowError err
  end
end


(* @dev:   Owner can topup the amount of rewards and extend the contract life.  *)
(* @Requirements: *)
(* - `` Amount should if it's a full multiple of the immutable rewards, otherwise an `???` error is thrown *)
transition OwnerTopUpRewards(amount: Uint128)
  IsContractOwner;
  RewardIfEpoch;
  (* use reward_per_epoch to check if the incoming amount is a mutiple, otherwise people will get mad with a partial reward
     so is reward is 100Z, this should accept 200Z, 300Z...*)
  rewards_left <- total_rewards_left;
  (*
    modulus_rewards = builtin rem immutable_reward_per_epoch amount;
    is_perfect_division = builtin eq modulus_rewards uint128_zero; 
  *)
  (* move reward to contract and update *)
  MoveFungibleTokenFromXToY utc reward_token_contract _sender _this_address amount;
  new_rewards_left = builtin add rewards_left amount;
  total_rewards_left:= new_rewards_left;
  e = {_eventname : "OwnerTopUpRewardsSuccess"; amount_sent : amount; contract_held: new_rewards_left};
  event e
end

(*
  
*)

(* @dev: Owner can change the time that a reward calculation is performed, can be zero  *)
(* @dev: Implications of a short epoch time are that users are eligible for rewards and therefore more calculations and gas is required  *)
(* @dev: This could expend contract funds quickly if a large reward is set. *)
(* @dev: Implications of a long epoch time are that when a similar  *)
(* @Requirements: *)
(* - `pool[_sender]` should have a users address present otherwise an `SenderHasNoFundsAtContract` error is thrown *)
(* - `tax_amount_as_uint256` has the potential to overflow, if so, a `MathError` error is thrown *)
(* - `withdraw_amount` should be equal to or larger than Uint128 10 otherwise tax cannot be applied *)
(* - `` Amount should if it's a full multiple of the immutable rewards, otherwise an `???` error is thrown *)
transition OwnerChangeEpochLength(new_epoch_length: Uint128)
  IsContractOwner;
  RewardIfEpoch;
  current_epoch_length := new_epoch_length;
  e = {_eventname : "OwnerChangeEpochLengthSuccess"; new_epoch_length: new_epoch_length};
  event e
end

(*
  Owner can change the minimum time that users are impacted by tax, can be zero
*)
transition OwnerChangeTaxLockTime(new_min_tax_time_in_blocks: Uint128)
  IsContractOwner;
  RewardIfEpoch;
  current_minimum_lock_time_no_tax := new_min_tax_time_in_blocks;
  e = {_eventname : "OwnerChangeTaxLockTimeSuccess"; new_tax_time: new_min_tax_time_in_blocks};
  event e
end

(*
  Allows owner can change the rate in which users are impacted by tax, can be zero
*)
transition OwnerChangeTaxRate(new_tax_rate_in_bps: Uint128) 
  IsContractOwner;
  RewardIfEpoch;
  current_early_leave_tax := new_tax_rate_in_bps;
  e = {_eventname : "OwnerChangeTaxRateSuccess"; new_tax_rate: new_tax_rate_in_bps};
  event e
end

(*
  Allows owner to reclaim total_taxed_amount (tax = tokens)
*)
transition OwnerClaimTax()
  IsContractOwner;
  RewardIfEpoch;
  tta <- total_taxed_amount;
  (* move tax to owner amd update  *)
  MoveFungibleTokenFromXToY ctu stake_token_contract _this_address _sender tta; 
  total_taxed_amount := uint128_zero;
  e = {_eventname : "OwnerClaimTaxSuccess"; tax_sent_to_owner : tta; contract_held_now: uint128_zero};
  event e
end


(*
  Contract must be paused if current_contract_owner wants to claim rewards (rewards = reward_token_contract) so that users can't
*)
transition OwnerReclaimRewards()
  IsContractOwner;
  RewardIfEpoch;
  is_paused <- paused;
  match is_paused with
    | True =>
      trl <- total_rewards_left;
      (* move rewards to owner amd update  *)
      MoveFungibleTokenFromXToY ctu reward_token_contract _this_address _sender trl; 
      total_rewards_left := uint128_zero;
      e = {_eventname : "OwnerReclaimRewardsSuccess"; rewards_taken:trl; contract_held_now: uint128_zero};
      event e
    | False =>
  end
end

(*
  allows current_contract_owner to toggle pause all interactions expect withdraws of inital (pauses withdraw of rewards)
*)
transition OwnerTogglePause(pause_state: Bool)
  IsContractOwner;
  RewardIfEpoch;
  paused := pause_state;
  e = {_eventname : "OwnerTogglePauseSuccess"; new_pause_state: pause_state};
  event e
end

(*
  current_contract_owner can stage a new staged_contract_owner address
*)
transition RequestOwnershipTransfer(new_owner : ByStr20)
  IsContractOwner;
  RewardIfEpoch;
  new_empty_staging = Some {ByStr20} new_owner;
  staged_contract_owner := new_empty_staging;
  e = {_eventname : "RequestOwnershipTransferSuccess"; staged_contract_owner: new_empty_staging};
  event e
end

(*
  after a new staged_contract_owner is set, that address can claim ownership
*)
transition ConfirmOwnershipTransfer()
  ChangeContractOwnershipIfSenderIsStagingOwner;
  RewardIfEpoch;
  e = {_eventname : "ConfirmOwnershipTransferSuccess"; new_contract_owner: _sender};
  event e
end


transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end

transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
end